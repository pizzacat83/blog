---
published: 2025-02-14
summary: |-
  あのイーハトーヴォのすきとおった風、夏でも底に冷たさをもつ青いそら、うつくしい森で飾られたモリーオ市、郊外のぎらぎらひかる草の波。
---
# F# でこのブログを構築した

周囲に触発されて英語ブログを書きたくなったが、どこに記事を置くかをいろいろ検討した結果、静的サイトジェネレータで構築することにした。このサイトの公開に至るまでの色々を気の赴くままに書いていく。

## このサイトの技術構成



## コンテンツを書くことに集中したい

さて英語ブログを書きたいと思い立ったわけだが、その手段として最も重要だと思った性質は、「書くことに集中できること」だと思った。だから実装なんかせずにブログサイトを使えば、あとはコンテンツを書くだけである。実際、今までブログをはてなブログに書いてきたが、「Markdown を書いて公開するだけ」という感覚で使えるのは魅力的だった。

しかし悲しいことに、なんというか気に入った英語ブログサイトがなかったので、静的サイトジェネレータを使うことにした。そこでざっくり要件を書き出すと:

- コンテンツを Markdown で書ける
- 記事ページに OGP タグをつけられる
- 外部サイトへのリンクを埋め込み表示できる
- フィードが生成される

それからもう一つ、「JavaScript をなるべく書かない縛りをやってみたい」という感情が湧いた。これまでフロントエンドは React や Vue などで書くことがほとんどだったが、JS という言語は、好きな言語の上位に入るかというと、そうではない。静的サイトジェネレータは大雑把にはファイル一式を読み込んで HTML ファイルを生成するのだから、「JS を書かない縛り」は結構可能そうに思える。

こうして静的サイトジェネレータを探す旅に出た。色々事例を眺めていると、「ジェネレータやプラグインの破壊的なアップデートに追従するのが大変」みたいな話をちらほら見かける。私はコンテンツを書いて公開したいのであって、ジェネレータの破壊的変更に対応したいわけじゃない。安定したジェネレータを使いたい。

しかし「非 JS」「安定」を意識して静的サイトジェネレータを探すと、なんというか気に入ったものが見つからない。「なんかイケてるやつを使いたい」という感情があることに気がついた。これと「安定」との両立が難しい。

そして、要件のうち「外部サイトへのリンクを埋め込み表示できる」が核心的である気がしてきた。Markdown ファイルのリンク先をフェッチしていい感じにレンダリングする必要があり、テンプレートのカスタマイズの枠をはみ出る。静的サイトジェネレータのドキュメントに目を通し、その世界観を理解し、埋め込み表示をするための諸々の処理が世界観のどこに収まるものなのかを考えて実装する必要があるような感触を得た。しかし私はコンテンツを書いて公開したいのであって、静的サイトジェネレータの世界観を理解してその中にリンク埋め込み機能をねじ込みたいわけではない。

なんというか、全ての要件と感情をスマートに満たす解は無い気がしてきた。

## 「コンテンツを書く」以外のタスクを楽しめる選択を: つまり自作

少し考え方を変えて、「要件を満たすためのカスタム実装や、アプデに追従するための改修を、ウキウキ進められるような選択をしよう」と考えた。コンテンツを書くことへの完全な集中は諦めて、コンテンツを書く以外のタスクを楽しめるかどうかを重視することにした。

ここで静的サイトジェネレータを自作することを思い立った。私は[ブラウザの自作に手を出した](./2025-01-10-flatt-xss-challenge-1)のだから、静的サイトジェネレータを自作してもおかしくはない。好きな言語でジェネレータを自作しよう。既成の静的サイトジェネレータの世界観を読み解く必要はない。言語の破壊的変更に追従する必要はあるかもしれないが、好きな言語だからそれは愛せる。

ジェネレータの実装に使う言語は、Rust か Scala にしようと思った。Scala は勉強したいと以前から思っていたが「Scala でつくりたいもの」がなかなか思い浮かばず、手をつけられていなかった。そこで静的サイトジェネレータの実装がてら Scala に入門しようと思ったが、残念ながら Scala のいい感じの Markdown パーサーライブラリを見つけられなかったので、Rust で実装することにした。Markdown パーサーを自作するという選択肢は取りたくなかった。記事を書きながら、「あ〜、自作パーサーは表の記法に対応してないんだった。実装重いから表は書かないでおくか」のような思考はしたくないからだ。

### 自作の第一歩: 人力サイトジェネレータ

ジェネレータを自作するにあたり最初にやったことは、生成したい HTML を一旦全部手で書くことである。Pandoc で Markdown ファイルを HTML に変換し、それにヘッダーやフッターを手で書き足して、CSS を書いた。手作業で HTML を生成する作業を少しずつ自動化していけば、静的サイトジェネレータが出来上がってくる、という算段である。たとえ私が道半ばで力尽きても、ブログサイトは公開できる。それに HTML 手書きなら、Rust のコンパイル時間を待つ必要もなく、サクサク見た目を調整できる。

デザインは、めちゃくちゃシンプルにするかめちゃくちゃ個性を出すのが好きだけれども、個性が出るデザインがパッと思いつかなかったので、めちゃくちゃシンプルにした。記事本文の文字サイズや行間は、自分が読みやすいと思える数値に調整した。

スタイルはフレームワークを使わずに手書きすることにした。これもまた、破壊的変更に追従する必要を減らすための決定である。しかし書いていると、`color: #333333;` とか逐一書くのがつらくなってきて、Tailwind の `text-gray-800` が恋しくなってくる。使う色には一定の統一感を持たせたいが、同じカラーコードを何箇所にもコピペするのはしんどい。そこで、CSS Variables で色を管理することにした。

```css
:root {
    --lighter-gray: #eee;
    --light-gray: #ddd;
    --gray: #888;
    --dim-gray: #666;
    --dark-gray: #333;
    --darker-gray: #111;

    --pale-blue: #3c7fac;
}
```

色の名前は、`--title` のような用途に即した名前ではなく、色そのものの名前をつけることにした。用途の適切な名前を考えるのも大変だし、例えば同じ「タイトル」という概念でも、場所によって使いたい色は違うかもしれない。色そのものの名前としては `--gray-3` のような名前をつける手もあったけれど、まあ CSS を書いている時の脳内は「明るいグレー」「真ん中のグレー」「暗めのグレー」「や、もうちょっと明るく」みたいに考えているので、`--light-gray`, `--gray`, `--dark-gray` +α という感じで名前をつけた。

話を脱線させると、一通り CSS を書いてから Tailwind の [Utility-First というコンセプトの説明](https://tailwindcss.com/docs/styling-with-utility-classes)を読んだ。従来の HTML と CSS を分けて書く方式と違って、クラス名を捻り出す必要がないし、2つのファイルを行き来する必要もないし、local に見た目を制御しているが故の安心感がある。インラインスタイルとの比較については、hover のような擬似クラスに依存する制御や、`@media` による制御を記述できることを長所としている。確かにそうだねえ……。CSS フレームワーク禁止縛りをして CSS を書いたことで、フレームワークがどういったメリットをもたらしているのかの理解度が高まったように感じる。

### 今度はライブラリ探しの旅へ

そんなこんなで人力サイトジェネレータでブログサイトをざっくり構築したので、次は静的サイトジェネレータの実装である。Markdown パーサーとしては [pulldown-cmark](https://crates.io/crates/pulldown-cmark) があり、パース結果を HTML に変換することもできる。テンプレートエンジンはどうしようか。

テンプレートエンジンと聞いてまず思い浮かぶのは [handlebars](https://crates.io/crates/handlebars) だった。しかし handlebars のようなテンプレート言語は Rust の型システム等とあまり連携していない。変数名の補完は効かないし、フィールド名を typo してもコンパイル時点では検出されず、実行時エラーとなる。enum を綺麗にパターンマッチできるわけでもない。頑張ってブログサイトの種々のデータを struct や enum で綺麗に定義しても、その恩恵は handlebars のテンプレート内では受けられないのだ。

また静的型システムは、数ヶ月前に書いたコードを思い出すのに役に立つ。コード辺のおおまかな仕様が型として表現されていて、静的型システムがその仕様を保証してくれているからだ。Rust の型システムと連携していない handlebars のテンプレートだと、「この変数はどういうデータ構造なんだっけ？」をなんとか探り出さねばならない。

というわけで handlebars を保留して Rust の型システムと連携したテンプレートエンジンを探し求めると、[askama](https://crates.io/crates/askama) を見つけた。これは type-safe, compiled Jinja-like templates を謳う。テンプレートファイルは、確かに見慣れた記法である。

```
Hello, {{ name }}!
```

このテンプレートファイルを、以下のように derive マクロで Rust の世界に取り込む。

```rust
#[derive(askama::Template)]
#[template(path = "hello.html")]
struct HelloTemplate<'a> {
    name: &'a str,
}
```

ここで `{{ nam }}` のようにフィールド名を typo したら、コンパイル時にちゃんと型エラーとして検出される。テンプレートの入力となるデータの型も明快である。パターンマッチの構文も用意されている。

ただ残念なのは、テンプレートを書くときの開発体験が、handlebars 等とさほど変わらないことだった。Askama の IntelliJ Plugin はあるものの、テンプレートファイルを編集する際には、コード補完や型エラーのフィードバック、jump to definition などの機能は提供されていないようだった (私の環境構築がうまくいっていないのかもしれない)。テンプレートを書くときの体験が、Rust の普通のコードを書く時と同じくらい快適ならいいのに…と思った。つまり欲しかったのは型システムだけではなく、Rust のエコシステムが全体として醸成するあの快適な開発体験だった。

そこで Rust 言語との統合性を軸にさらに調べると、[maud](https://maud.lambda.xyz/) というテンプレートエンジンを見つけた。

しかし、TSX が恋しい！脱線するが、TSX の開発体験は感動的だ。HTML と TypeScript を書き慣れていれば、いつも通り HTML や TS を書くだけで、望みの処理を実装できる。追加で覚えるべき文法は極めて少ない。そしてコード補完や型検査など、TS で使える強力なエディタ支援機能は TSX でも同様に使える。さらに、TS の型消去ベースのトランスパイルや hot loading 等の技術のおかげで、コードを保存すると即座にレンダリング結果を確認できる。

UI を実装するエコシステムにおいて、「コードを保存したらレンダリング結果を即座に確認できる」という性質は重要だと思っている。UI は人間がソフトウェアと接する部分であるから、「人間が見て・触って使いやすい」ということが主要なゴールであり、それを確かめるには人の目と手で確かめるのが第一である。それゆえに UI を実装する際はしばしば「見た目をちょっと変えて再確認」という周期の短いループが発生する。TSX のエコシステムはこの点でも UI 実装の開発体験に大きく寄与していると思う。

## そして出会った scriptable SSG using F#: Fornax

折しもこの時、『[関数型ドメインモデリング](https://tailwindcss.com/docs/styling-with-utility-classes)』という、サンプルコードが F# で書かれている本を読んでいた。これに触発されて、Rust ではなく F# でジェネレータを実装してみようかなと思った。そこで F# の Markdown パーサーライブラリを探す中で、F# で書かれた [Fornax](https://github.com/ionide/Fornax) という静的サイトジェネレータを知った。そしてこれに一目惚れした。

(なお、『関数型ドメインモデリング』を読むきっかけは、Rust.tokyo で関数型パラダイムでのドメイン駆動設計の話をちらほら聞いたからだ。Rust で進めようとしていたプロジェクトを F# に方針転換したきっかけが Rust.tokyo だというのは皮肉な話である。)

さて Fornax の何に一目惚れしたか。それは、10分でその世界観を理解でき、どうすれば所望のブログサイトを生成できるかがはっきりとわかることである。

Fornax のドキュメントは [GitHub にある README](https://github.com/ionide/Fornax/blob/master/README.md) の一枚がほぼ全てである。全体の概要は数分流し読みすれば掴めると思うので、読んでみてほしい。

ただでさえ簡潔明瞭なこのドキュメントをさらに要約すると、Fornax では、サイトの生成方法をユーザーが F# スクリプトで記述する。ユーザーは、データを読み込む loaders, 読み込んだデータからファイルを生成する generators, そして諸々の設定を書く config の3種のスクリプトを書く。F# スクリプトゆえ、カスタマイズの自由度は極めて高い。ファイルシステムからデータを取得してもいいし、何かの API をフェッチしてもいい。HTML を生成することも、RSS を生成することもできる。その手続きを F# で普通に実装するだけで、これらが実現できる。外部リンクの OGP タグを抽出して埋め込むのだって、F# でその処理を実装する方法はなんとなく想像がつくから、その通りに書けば良い。


